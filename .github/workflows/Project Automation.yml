name: Project Automation

on:
  issues:
    types: [opened, edited, assigned, closed, labeled, unlabeled, reopened]
  pull_request:
    types: [opened, ready_for_review, closed, converted_to_draft, reopened]

jobs:
  # Job 1: 이슈 생성/수정 시 자동으로 라벨링
  auto_label:
    name: Auto Label from Issue Body
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && (github.event.action == 'opened' || github.event.action == 'edited')
    steps:
      - name: Auto label from template
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const labelsToAdd = [];
            const platformMap = {'⚙️ Backend': 'platform: backend ⚙️', '💻 Frontend': 'platform: frontend 💻', '🤖 Android': 'platform: android 🤖', '📱 iOS': 'platform: ios 📱', '🎯 All': 'platform: all 🎯'};
            const epicMap = {'📦 세팅': 'epic: setup 📦', '🎨 디자인시스템': 'epic: design-system 🎨', '👤 로그인/회원가입': 'epic: auth 👤', '🙍‍♂️ 프로필': 'epic: profile 🙍‍♂️', '💬 커뮤니티': 'epic: community 💬', '⚙️ 설정': 'epic: settings ⚙️', '🔮 향후 계획': 'epic: future 🔮'};
            const priorityMap = {
              '🔥 High': 'priority: high 🔥',
              '🔥 Critical': 'priority: high 🔥', // Critical을 High로 매핑
              '⚡ Medium': 'priority: medium ⚡',
              '🌱 Low': 'priority: low 🌱'
            };
            function parseAndAddLabel(fieldName, map) {
              const regex = new RegExp(`### ${fieldName}\\s*\\n\\s*([^\n]+)`);
              const match = body.match(regex);
              if (match) {
                const value = match[1].trim();
                for (const [key, label] of Object.entries(map)) {
                  if (value.includes(key)) {
                    labelsToAdd.push(label);
                    return;
                  }
                }
              }
            }
            parseAndAddLabel('플랫폼', platformMap);
            parseAndAddLabel('Epic \\(대분류\\)', epicMap);
            parseAndAddLabel('우선순위', priorityMap);
            parseAndAddLabel('심각도 \\(Severity\\)', priorityMap);
            
            if (labelsToAdd.length > 0) {
              const existingLabels = issue.labels.map(l => l.name);
              const finalLabels = [...new Set([...existingLabels, ...labelsToAdd])];
              await github.rest.issues.setLabels({
                owner: context.repo.owner, repo: context.repo.repo,
                issue_number: issue.number, labels: finalLabels
              });
            }

  # Job 2: 프로젝트 추가 및 필드 설정 (auto_label 작업이 끝난 후 실행)
  add_to_project_and_set_fields:
    name: Add to Project and Set Fields
    runs-on: ubuntu-latest
    needs: auto_label
    if: github.event_name == 'issues' && github.event.action == 'opened'
    steps:
      - name: Add to project and set fields
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADD_TO_PROJECT_PAT }}
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const { data: updated_issue } = await github.rest.issues.get({
              owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number
            });
            const labels = updated_issue.labels.map(label => label.name);
            console.log('Final labels from API:', labels);
            
            const projectQuery = `
              query($org: String!, $number: Int!) {
                organization(login: $org) {
                  projectV2(number: $number) {
                    id
                    fields(first: 30) {
                      nodes {
                        ... on ProjectV2Field { id, name, dataType }
                        ... on ProjectV2SingleSelectField { id, name, options { id, name } }
                        ... on ProjectV2IterationField { id, name, configuration { iterations { id, title } } }
                      }
                    }
                  }
                }
              }`;
            
            const projectData = await github.graphql(projectQuery, { org: 'jiu-jitsu-org', number: 1 });
            const project = projectData.organization.projectV2;
            const fields = project.fields.nodes;
            
            const statusField = fields.find(f => f.name === 'Status');
            const priorityField = fields.find(f => f.name === 'Priority');
            const epicField = fields.find(f => f.name === 'Epic');
            const sprintField = fields.find(f => f.name === 'Sprint');
            const startDateField = fields.find(f => f.name === 'Start date' && f.dataType === 'DATE');
            const dueDateField = fields.find(f => f.name === 'Due date' && f.dataType === 'DATE');

            const addItemMutation = `mutation($pId: ID!, $cId: ID!) { addProjectV2ItemById(input: { projectId: $pId, contentId: $cId }) { item { id } } }`;
            const addResult = await github.graphql(addItemMutation, { pId: project.id, cId: issue.node_id });
            const itemId = addResult.addProjectV2ItemById.item.id;
            console.log('Added item to project:', itemId);
            
            function parseValue(fieldName) {
              const regex = new RegExp(`### ${fieldName}\\s*\\n\\s*([^\n]+)`);
              const match = body.match(regex);
              return match ? match[1].trim() : null;
            }
            
            const sprintValue = parseValue('Sprint');
            const startDateValue = parseValue('시작 예정일');
            const dueDateValue = parseValue('완료 예정일');
            
            const updateFieldMutation = `mutation($pId: ID!, $iId: ID!, $fId: ID!, $val: ProjectV2FieldValue!) { updateProjectV2ItemFieldValue(input: { projectId: $pId, itemId: $iId, fieldId: $fId, value: $val }) { projectV2Item { id } } }`;
            
            // Single-Select 필드 업데이트
            let statusValue = 'Backlog', priorityValue = null, epicValue = null;
            if (labels.includes('priority: high 🔥')) priorityValue = '🔥 High'; else if (labels.includes('priority: medium ⚡')) priorityValue = '⚡ Medium'; else if (labels.includes('priority: low 🌱')) priorityValue = '🌱 Low';
            if (labels.includes('epic: auth 👤')) epicValue = '👤 로그인/회원가입'; else if (labels.includes('epic: setup 📦')) epicValue = '📦 세팅'; else if (labels.includes('epic: design-system 🎨')) epicValue = '🎨 디자인시스템'; else if (labels.includes('epic: profile 🙍‍♂️')) epicValue = '🙍‍♂️ 프로필'; else if (labels.includes('epic: community 💬')) epicValue = '💬 커뮤니티'; else if (labels.includes('epic: settings ⚙️')) epicValue = '⚙️ 설정'; else if (labels.includes('epic: future 🔮')) epicValue = '🔮 향후 계획';

            async function updateSelectField(field, value) {
              if (field && value) {
                const option = field.options?.find(o => o.name === value);
                if (option) { await github.graphql(updateFieldMutation, { pId: project.id, iId: itemId, fId: field.id, val: { singleSelectOptionId: option.id } }); console.log(`Updated ${field.name} to:`, value); }
              }
            }
            await updateSelectField(statusField, statusValue);
            await updateSelectField(priorityField, priorityValue);
            await updateSelectField(epicField, epicValue);

            // Sprint (Iteration) 필드 업데이트
            if (sprintField && sprintValue) {
              // 이슈 폼의 옵션 값과 실제 프로젝트의 Sprint 필드명을 1:1로 매핑합니다.
              const sprintMap = {
                "🏁 Sprint 1 (Current: ~9/14)": "Sprint 1",
                "🗓️ Sprint 2 (Planned)": "Sprint 2",
                "🗓️ Sprint 3 (Planned)": "Sprint 3"
              };

              const targetTitle = sprintMap[sprintValue];
              if (targetTitle) {
                const iterations = sprintField.configuration.iterations;
                const targetIteration = iterations.find(it => it.title === targetTitle);
                
                if (targetIteration) {
                  await github.graphql(updateFieldMutation, { pId: project.id, iId: itemId, fId: sprintField.id, val: { iterationId: targetIteration.id } });
                  console.log('Updated Sprint to:', targetIteration.title);
                } else {
                  console.log(`Could not find a project iteration with the exact title: ${targetTitle}`);
                }
              }
            }

            // Date 필드 업데이트
            if (startDateField && startDateValue && /^\d{4}-\d{2}-\d{2}$/.test(startDateValue)) {
              await github.graphql(updateFieldMutation, { pId: project.id, iId: itemId, fId: startDateField.id, val: { date: startDateValue } });
              console.log('Updated Start date to:', startDateValue);
            }
            if (dueDateField && dueDateValue && /^\d{4}-\d{2}-\d{2}$/.test(dueDateValue)) {
              await github.graphql(updateFieldMutation, { pId: project.id, iId: itemId, fId: dueDateField.id, val: { date: dueDateValue } });
              console.log('Updated Due date to:', dueDateValue);
            }

  # Job 3: 라벨 변경 시 프로젝트 필드 업데이트
  update_project_fields_on_label:
    name: Update Project Fields on Label Change
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && (github.event.action == 'labeled' || github.event.action == 'unlabeled')
    steps:
      - name: Update project fields based on label changes
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADD_TO_PROJECT_PAT }}
          script: |
            const issue = context.payload.issue;
            const labels = issue.labels.map(l => l.name);
            const labelName = context.payload.label.name;
            const findItemQuery = `
              query($org: String!, $number: Int!) {
                organization(login: $org) {
                  projectV2(number: $number) {
                    id
                    items(first: 100, orderBy: {field: POSITION, direction: DESC}) {
                      nodes { id, content { ... on Issue { id, number, repository { name } } } }
                    }
                    fields(first: 20) {
                      nodes { ... on ProjectV2SingleSelectField { id, name, options { id, name } } }
                    }
                  }
                }
              }`;
            const projectData = await github.graphql(findItemQuery, { org: 'jiu-jitsu-org', number: 1 });
            const project = projectData.organization.projectV2;
            const projectItem = project.items.nodes.find(item => item.content?.repository.name === context.repo.repo && item.content?.number === issue.number);
            if (!projectItem) { return; }
            
            const fields = project.fields.nodes;
            const updateFieldMutation = `mutation($pId: ID!, $iId: ID!, $fId: ID!, $val: ProjectV2FieldValue!) { updateProjectV2ItemFieldValue(input: { projectId: $pId, itemId: $iId, fieldId: $fId, value: $val }) { projectV2Item { id } } }`;
            
            async function updateField(fieldName, labelPrefix, valueMap) {
              if (labelName.startsWith(labelPrefix)) {
                const field = fields.find(f => f.name === fieldName);
                if (field) {
                  let newValue = null;
                  const currentLabel = labels.find(l => l.startsWith(labelPrefix));
                  if (currentLabel) {
                    for (const [key, value] of Object.entries(valueMap)) { if (currentLabel.includes(key)) { newValue = value; break; } }
                  }
                  if (newValue) {
                    const option = field.options?.find(o => o.name === newValue);
                    if (option) { await github.graphql(updateFieldMutation, { pId: project.id, iId: projectItem.id, fId: field.id, val: { singleSelectOptionId: option.id } }); }
                  }
                }
              }
            }
            await updateField('Status', 'status:', { 'in-progress': 'In Progress', 'review': 'In Review', 'done': 'Done', 'blocked': 'Blocked' });
            await updateField('Priority', 'priority:', { 'high': '🔥 High', 'medium': '⚡ Medium', 'low': '🌱 Low' });
            await updateField('Epic', 'epic:', { 'setup': '📦 세팅', 'design-system': '🎨 디자인시스템', 'auth': '👤 로그인/회원가입' });

  # Job 4: 담당자 할당시 라벨 추가
  move_assigned_to_progress:
    name: Add Label on Assign
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'assigned'
    steps:
      - name: Add in-progress label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner, repo: context.repo.repo,
              issue_number: context.issue.number, labels: ['status: in-progress 🔄']
            });

  # PR 관련 자동화 Job들
  pr_automation:
    name: Handle PR Status Change
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Update labels based on PR action
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const action = context.payload.action;
            const existingLabels = pr.labels.map(l => l.name);
            let labelsToSet = existingLabels.filter(label => !label.startsWith('status:'));
            
            if (action === 'ready_for_review') labelsToSet.push('status: review 👀');
            else if (action === 'converted_to_draft') labelsToSet.push('status: in-progress 🔄');
            else if (action === 'closed' && pr.merged) labelsToSet.push('status: done ✅');
            else if (action === 'reopened') labelsToSet.push('status: in-progress 🔄');
            
            if (JSON.stringify(existingLabels.sort()) !== JSON.stringify(labelsToSet.sort())) {
              await github.rest.issues.setLabels({
                owner: context.repo.owner, repo: context.repo.repo,
                issue_number: pr.number, labels: [...new Set(labelsToSet)]
              });
            }
