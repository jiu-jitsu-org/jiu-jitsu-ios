name: Project Automation

on:
  issues:
    types: [opened, edited, assigned, closed, labeled, unlabeled, reopened]
  pull_request:
    types: [opened, ready_for_review, closed, converted_to_draft, reopened]

jobs:
  # Job 1: ì´ìŠˆ ìƒì„±/ìˆ˜ì • ì‹œ ìžë™ìœ¼ë¡œ ë¼ë²¨ë§
  auto_label:
    name: Auto Label from Issue Body
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && (github.event.action == 'opened' || github.event.action == 'edited')
    steps:
      - name: Auto label from template
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const labelsToAdd = [];
            const platformMap = {'âš™ï¸ Backend': 'platform: backend âš™ï¸', 'ðŸ’» Frontend': 'platform: frontend ðŸ’»', 'ðŸ¤– Android': 'platform: android ðŸ¤–', 'ðŸ“± iOS': 'platform: ios ðŸ“±', 'ðŸŽ¯ All': 'platform: all ðŸŽ¯'};
            const epicMap = {'ðŸ“¦ ì„¸íŒ…': 'epic: setup ðŸ“¦', 'ðŸŽ¨ ë””ìžì¸ì‹œìŠ¤í…œ': 'epic: design-system ðŸŽ¨', 'ðŸ‘¤ ë¡œê·¸ì¸/íšŒì›ê°€ìž…': 'epic: auth ðŸ‘¤', 'ðŸ™â€â™‚ï¸ í”„ë¡œí•„': 'epic: profile ðŸ™â€â™‚ï¸', 'ðŸ’¬ ì»¤ë®¤ë‹ˆí‹°': 'epic: community ðŸ’¬', 'âš™ï¸ ì„¤ì •': 'epic: settings âš™ï¸', 'ðŸ”® í–¥í›„ ê³„íš': 'epic: future ðŸ”®'};
            const priorityMap = {
              'ðŸ”¥ High': 'priority: high ðŸ”¥',
              'ðŸ”¥ Critical': 'priority: high ðŸ”¥', // Criticalì„ Highë¡œ ë§¤í•‘
              'âš¡ Medium': 'priority: medium âš¡',
              'ðŸŒ± Low': 'priority: low ðŸŒ±'
            };
            function parseAndAddLabel(fieldName, map) {
              const regex = new RegExp(`### ${fieldName}\\s*\\n\\s*([^\n]+)`);
              const match = body.match(regex);
              if (match) {
                const value = match[1].trim();
                for (const [key, label] of Object.entries(map)) {
                  if (value.includes(key)) {
                    labelsToAdd.push(label);
                    return;
                  }
                }
              }
            }
            parseAndAddLabel('í”Œëž«í¼', platformMap);
            parseAndAddLabel('Epic \\(ëŒ€ë¶„ë¥˜\\)', epicMap);
            parseAndAddLabel('ìš°ì„ ìˆœìœ„', priorityMap);
            parseAndAddLabel('ì‹¬ê°ë„ \\(Severity\\)', priorityMap);
            
            if (labelsToAdd.length > 0) {
              const existingLabels = issue.labels.map(l => l.name);
              const finalLabels = [...new Set([...existingLabels, ...labelsToAdd])];
              await github.rest.issues.setLabels({
                owner: context.repo.owner, repo: context.repo.repo,
                issue_number: issue.number, labels: finalLabels
              });
            }

  # Job 2: í”„ë¡œì íŠ¸ ì¶”ê°€ ë° í•„ë“œ ì„¤ì • (auto_label ìž‘ì—…ì´ ëë‚œ í›„ ì‹¤í–‰)
  add_to_project_and_set_fields:
    name: Add to Project and Set Fields
    runs-on: ubuntu-latest
    needs: auto_label
    if: github.event_name == 'issues' && github.event.action == 'opened'
    steps:
      - name: Add to project and set fields
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADD_TO_PROJECT_PAT }}
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const { data: updated_issue } = await github.rest.issues.get({
              owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number
            });
            const labels = updated_issue.labels.map(label => label.name);
            console.log('Final labels from API:', labels);
            
            const projectQuery = `
              query($org: String!, $number: Int!) {
                organization(login: $org) {
                  projectV2(number: $number) {
                    id
                    fields(first: 30) {
                      nodes {
                        ... on ProjectV2Field { id, name, dataType }
                        ... on ProjectV2SingleSelectField { id, name, options { id, name } }
                        ... on ProjectV2IterationField { id, name, configuration { iterations { id, title } } }
                      }
                    }
                  }
                }
              }`;
            
            const projectData = await github.graphql(projectQuery, { org: 'jiu-jitsu-org', number: 1 });
            const project = projectData.organization.projectV2;
            const fields = project.fields.nodes;
            
            const statusField = fields.find(f => f.name === 'Status');
            const priorityField = fields.find(f => f.name === 'Priority');
            const epicField = fields.find(f => f.name === 'Epic');
            const sprintField = fields.find(f => f.name === 'Sprint');
            const startDateField = fields.find(f => f.name === 'Start date' && f.dataType === 'DATE');
            const dueDateField = fields.find(f => f.name === 'Due date' && f.dataType === 'DATE');

            const addItemMutation = `mutation($pId: ID!, $cId: ID!) { addProjectV2ItemById(input: { projectId: $pId, contentId: $cId }) { item { id } } }`;
            const addResult = await github.graphql(addItemMutation, { pId: project.id, cId: issue.node_id });
            const itemId = addResult.addProjectV2ItemById.item.id;
            console.log('Added item to project:', itemId);
            
            function parseValue(fieldName) {
              const regex = new RegExp(`### ${fieldName}\\s*\\n\\s*([^\n]+)`);
              const match = body.match(regex);
              return match ? match[1].trim() : null;
            }
            
            const sprintValue = parseValue('Sprint');
            const startDateValue = parseValue('ì‹œìž‘ ì˜ˆì •ì¼');
            const dueDateValue = parseValue('ì™„ë£Œ ì˜ˆì •ì¼');
            
            const updateFieldMutation = `mutation($pId: ID!, $iId: ID!, $fId: ID!, $val: ProjectV2FieldValue!) { updateProjectV2ItemFieldValue(input: { projectId: $pId, itemId: $iId, fieldId: $fId, value: $val }) { projectV2Item { id } } }`;
            
            // Single-Select í•„ë“œ ì—…ë°ì´íŠ¸
            let statusValue = 'Backlog', priorityValue = null, epicValue = null;
            if (labels.includes('priority: high ðŸ”¥')) priorityValue = 'ðŸ”¥ High'; else if (labels.includes('priority: medium âš¡')) priorityValue = 'âš¡ Medium'; else if (labels.includes('priority: low ðŸŒ±')) priorityValue = 'ðŸŒ± Low';
            if (labels.includes('epic: auth ðŸ‘¤')) epicValue = 'ðŸ‘¤ ë¡œê·¸ì¸/íšŒì›ê°€ìž…'; else if (labels.includes('epic: setup ðŸ“¦')) epicValue = 'ðŸ“¦ ì„¸íŒ…'; else if (labels.includes('epic: design-system ðŸŽ¨')) epicValue = 'ðŸŽ¨ ë””ìžì¸ì‹œìŠ¤í…œ'; else if (labels.includes('epic: profile ðŸ™â€â™‚ï¸')) epicValue = 'ðŸ™â€â™‚ï¸ í”„ë¡œí•„'; else if (labels.includes('epic: community ðŸ’¬')) epicValue = 'ðŸ’¬ ì»¤ë®¤ë‹ˆí‹°'; else if (labels.includes('epic: settings âš™ï¸')) epicValue = 'âš™ï¸ ì„¤ì •'; else if (labels.includes('epic: future ðŸ”®')) epicValue = 'ðŸ”® í–¥í›„ ê³„íš';

            async function updateSelectField(field, value) {
              if (field && value) {
                const option = field.options?.find(o => o.name === value);
                if (option) { await github.graphql(updateFieldMutation, { pId: project.id, iId: itemId, fId: field.id, val: { singleSelectOptionId: option.id } }); console.log(`Updated ${field.name} to:`, value); }
              }
            }
            await updateSelectField(statusField, statusValue);
            await updateSelectField(priorityField, priorityValue);
            await updateSelectField(epicField, epicValue);

            // Sprint (Iteration) í•„ë“œ ì—…ë°ì´íŠ¸
            if (sprintField && sprintValue) {
              // ì´ìŠˆ í¼ì˜ ì˜µì…˜ ê°’ê³¼ ì‹¤ì œ í”„ë¡œì íŠ¸ì˜ Sprint í•„ë“œëª…ì„ 1:1ë¡œ ë§¤í•‘í•©ë‹ˆë‹¤.
              const sprintMap = {
                "ðŸ Sprint 1 (Current: ~9/14)": "Sprint 1",
                "ðŸ—“ï¸ Sprint 2 (Planned)": "Sprint 2",
                "ðŸ—“ï¸ Sprint 3 (Planned)": "Sprint 3"
              };

              const targetTitle = sprintMap[sprintValue];
              if (targetTitle) {
                const iterations = sprintField.configuration.iterations;
                const targetIteration = iterations.find(it => it.title === targetTitle);
                
                if (targetIteration) {
                  await github.graphql(updateFieldMutation, { pId: project.id, iId: itemId, fId: sprintField.id, val: { iterationId: targetIteration.id } });
                  console.log('Updated Sprint to:', targetIteration.title);
                } else {
                  console.log(`Could not find a project iteration with the exact title: ${targetTitle}`);
                }
              }
            }

            // Date í•„ë“œ ì—…ë°ì´íŠ¸
            if (startDateField && startDateValue && /^\d{4}-\d{2}-\d{2}$/.test(startDateValue)) {
              await github.graphql(updateFieldMutation, { pId: project.id, iId: itemId, fId: startDateField.id, val: { date: startDateValue } });
              console.log('Updated Start date to:', startDateValue);
            }
            if (dueDateField && dueDateValue && /^\d{4}-\d{2}-\d{2}$/.test(dueDateValue)) {
              await github.graphql(updateFieldMutation, { pId: project.id, iId: itemId, fId: dueDateField.id, val: { date: dueDateValue } });
              console.log('Updated Due date to:', dueDateValue);
            }

  # Job 3: ë¼ë²¨ ë³€ê²½ ì‹œ í”„ë¡œì íŠ¸ í•„ë“œ ì—…ë°ì´íŠ¸
  update_project_fields_on_label:
    name: Update Project Fields on Label Change
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && (github.event.action == 'labeled' || github.event.action == 'unlabeled')
    steps:
      - name: Update project fields based on label changes
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADD_TO_PROJECT_PAT }}
          script: |
            const issue = context.payload.issue;
            const labels = issue.labels.map(l => l.name);
            const labelName = context.payload.label.name;
            const findItemQuery = `
              query($org: String!, $number: Int!) {
                organization(login: $org) {
                  projectV2(number: $number) {
                    id
                    items(first: 100, orderBy: {field: POSITION, direction: DESC}) {
                      nodes { id, content { ... on Issue { id, number, repository { name } } } }
                    }
                    fields(first: 20) {
                      nodes { ... on ProjectV2SingleSelectField { id, name, options { id, name } } }
                    }
                  }
                }
              }`;
            const projectData = await github.graphql(findItemQuery, { org: 'jiu-jitsu-org', number: 1 });
            const project = projectData.organization.projectV2;
            const projectItem = project.items.nodes.find(item => item.content?.repository.name === context.repo.repo && item.content?.number === issue.number);
            if (!projectItem) { return; }
            
            const fields = project.fields.nodes;
            const updateFieldMutation = `mutation($pId: ID!, $iId: ID!, $fId: ID!, $val: ProjectV2FieldValue!) { updateProjectV2ItemFieldValue(input: { projectId: $pId, itemId: $iId, fieldId: $fId, value: $val }) { projectV2Item { id } } }`;
            
            async function updateField(fieldName, labelPrefix, valueMap) {
              if (labelName.startsWith(labelPrefix)) {
                const field = fields.find(f => f.name === fieldName);
                if (field) {
                  let newValue = null;
                  const currentLabel = labels.find(l => l.startsWith(labelPrefix));
                  if (currentLabel) {
                    for (const [key, value] of Object.entries(valueMap)) { if (currentLabel.includes(key)) { newValue = value; break; } }
                  }
                  if (newValue) {
                    const option = field.options?.find(o => o.name === newValue);
                    if (option) { await github.graphql(updateFieldMutation, { pId: project.id, iId: projectItem.id, fId: field.id, val: { singleSelectOptionId: option.id } }); }
                  }
                }
              }
            }
            await updateField('Status', 'status:', { 'in-progress': 'In Progress', 'review': 'In Review', 'done': 'Done', 'blocked': 'Blocked' });
            await updateField('Priority', 'priority:', { 'high': 'ðŸ”¥ High', 'medium': 'âš¡ Medium', 'low': 'ðŸŒ± Low' });
            await updateField('Epic', 'epic:', { 'setup': 'ðŸ“¦ ì„¸íŒ…', 'design-system': 'ðŸŽ¨ ë””ìžì¸ì‹œìŠ¤í…œ', 'auth': 'ðŸ‘¤ ë¡œê·¸ì¸/íšŒì›ê°€ìž…' });

  # Job 4: ë‹´ë‹¹ìž í• ë‹¹ì‹œ ë¼ë²¨ ì¶”ê°€
  move_assigned_to_progress:
    name: Add Label on Assign
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'assigned'
    steps:
      - name: Add in-progress label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner, repo: context.repo.repo,
              issue_number: context.issue.number, labels: ['status: in-progress ðŸ”„']
            });

  # PR ê´€ë ¨ ìžë™í™” Jobë“¤
  pr_automation:
    name: Handle PR Status Change
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Update labels based on PR action
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const action = context.payload.action;
            const existingLabels = pr.labels.map(l => l.name);
            let labelsToSet = existingLabels.filter(label => !label.startsWith('status:'));
            
            if (action === 'ready_for_review') labelsToSet.push('status: review ðŸ‘€');
            else if (action === 'converted_to_draft') labelsToSet.push('status: in-progress ðŸ”„');
            else if (action === 'closed' && pr.merged) labelsToSet.push('status: done âœ…');
            else if (action === 'reopened') labelsToSet.push('status: in-progress ðŸ”„');
            
            if (JSON.stringify(existingLabels.sort()) !== JSON.stringify(labelsToSet.sort())) {
              await github.rest.issues.setLabels({
                owner: context.repo.owner, repo: context.repo.repo,
                issue_number: pr.number, labels: [...new Set(labelsToSet)]
              });
            }
