name: Project Automation

on:
  issues:
    types: [opened, edited, assigned, closed, labeled, unlabeled, reopened]
  pull_request:
    types: [opened, ready_for_review, closed, converted_to_draft, reopened]
  push:

jobs:
  # Job 1: ì´ìŠˆ ìƒì„±/ìˆ˜ì • ì‹œ ìžë™ìœ¼ë¡œ ë¼ë²¨ë§ (ê¸°ì¡´ ê¸°ëŠ¥ ìœ ì§€)
  auto_label:
    name: Auto Label from Issue Body
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && (github.event.action == 'opened' || github.event.action == 'edited')
    steps:
      - name: Auto label from template
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const labelsToAdd = [];
            const platformMap = {'âš™ï¸ Backend': 'platform: backend âš™ï¸', 'ðŸ’» Frontend': 'platform: frontend ðŸ’»', 'ðŸ¤– Android': 'platform: android ðŸ¤–', 'ðŸ“± iOS': 'platform: ios ðŸ“±', 'ðŸŽ¯ All': 'platform: all ðŸŽ¯'};
            const epicMap = {'ðŸ“¦ ì„¸íŒ…': 'epic: setup ðŸ“¦', 'ðŸŽ¨ ë””ìžì¸ì‹œìŠ¤í…œ': 'epic: design-system ðŸŽ¨', 'ðŸ‘¤ ë¡œê·¸ì¸/íšŒì›ê°€ìž…': 'epic: auth ðŸ‘¤', 'ðŸ™â€â™‚ï¸ í”„ë¡œí•„': 'epic: profile ðŸ™â€â™‚ï¸', 'ðŸ’¬ ì»¤ë®¤ë‹ˆí‹°': 'epic: community ðŸ’¬', 'âš™ï¸ ì„¤ì •': 'epic: settings âš™ï¸', 'ðŸ”® í–¥í›„ ê³„íš': 'epic: future ðŸ”®'};
            const priorityMap = {'ðŸ”¥ High': 'priority: high ðŸ”¥', 'ðŸ”¥ Critical': 'priority: high ðŸ”¥', 'âš¡ Medium': 'priority: medium âš¡', 'ðŸŒ± Low': 'priority: low ðŸŒ±'};

            function parseAndAddLabel(fieldName, map) {
              const escapedFieldName = fieldName.replace(/[()]/g, '\\$&');
              const regex = new RegExp(`### ${escapedFieldName}\\s*\\n\\s*([^\n]+)`);
              const match = body.match(regex);
              if (match) {
                const value = match[1].trim();
                for (const [key, label] of Object.entries(map)) { if (value.startsWith(key)) { labelsToAdd.push(label); return; } }
              }
            }
            parseAndAddLabel('í”Œëž«í¼', platformMap);
            parseAndAddLabel('Epic (ëŒ€ë¶„ë¥˜)', epicMap);
            parseAndAddLabel('ìš°ì„ ìˆœìœ„', priorityMap);
            parseAndAddLabel('ì‹¬ê°ë„ (Severity)', priorityMap);
            
            if (labelsToAdd.length > 0) {
              const existingLabels = issue.labels.map(l => l.name);
              const finalLabels = [...new Set([...existingLabels, ...labelsToAdd])];
              await github.rest.issues.setLabels({
                owner: context.repo.owner, repo: context.repo.repo,
                issue_number: issue.number, labels: finalLabels
              });
            }

  # Job 2: [ìˆ˜ì •] í”„ë¡œì íŠ¸ ì¶”ê°€ ë° í•„ë“œ ì„¤ì • (ë§¤í•‘ ë¡œì§ í†µì¼)
  add_to_project_and_set_fields:
    name: Add to Project and Set Fields
    runs-on: ubuntu-latest
    needs: auto_label
    if: github.event_name == 'issues' && github.event.action == 'opened'
    steps:
      - name: Add to project and set fields
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADD_TO_PROJECT_PAT }}
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            try {
              await github.rest.issues.addLabels({ owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number, labels: ['status: backlog ðŸ“‹'] });
            } catch (error) { console.log('Could not add "status: backlog ðŸ“‹" label:', error.message); }

            const { data: updated_issue } = await github.rest.issues.get({ owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number });
            const labels = updated_issue.labels.map(label => label.name);
            
            const projectQuery = `query($org: String!, $number: Int!) { organization(login: $org) { projectV2(number: $number) { id, fields(first: 30) { nodes { ... on ProjectV2Field { id, name, dataType } ... on ProjectV2SingleSelectField { id, name, options { id, name } } ... on ProjectV2IterationField { id, name, configuration { iterations { id, title } } } } } } } }`;
            const projectData = await github.graphql(projectQuery, { org: context.repo.owner, number: 1 });
            const project = projectData.organization.projectV2;
            const fields = project.fields.nodes;
            
            const statusField = fields.find(f => f.name === 'Status');
            const priorityField = fields.find(f => f.name === 'Priority');
            const epicField = fields.find(f => f.name === 'Epic');
            const sprintField = fields.find(f => f.name === 'Sprint');
            const startDateField = fields.find(f => f.name === 'Start date' && f.dataType === 'DATE');
            const dueDateField = fields.find(f => f.name === 'Due date' && f.dataType === 'DATE');

            const addItemMutation = `mutation($pId: ID!, $cId: ID!) { addProjectV2ItemById(input: { projectId: $pId, contentId: $cId }) { item { id } } }`;
            const addResult = await github.graphql(addItemMutation, { pId: project.id, cId: issue.node_id });
            const itemId = addResult.addProjectV2ItemById.item.id;
            
            function parseValue(fieldName) {
              const regex = new RegExp(`### ${fieldName}\\s*\\n\\s*([^\n]+)`);
              const match = body.match(regex);
              return match ? match[1].trim() : null;
            }
            
            const sprintValue = parseValue('Sprint');
            const startDateValue = parseValue('ì‹œìž‘ ì˜ˆì •ì¼');
            const dueDateValue = parseValue('ì™„ë£Œ ì˜ˆì •ì¼');
            
            const updateFieldMutation = `mutation($pId: ID!, $iId: ID!, $fId: ID!, $val: ProjectV2FieldValue!) { updateProjectV2ItemFieldValue(input: { projectId: $pId, itemId: $iId, fieldId: $fId, value: $val }) { projectV2Item { id } } }`;
            
            // --- [ì˜¤ë¥˜ ìˆ˜ì •] ë§¤í•‘ ë¡œì§ì„ Map ê¸°ë°˜ìœ¼ë¡œ í†µì¼ ---
            const priorityMap = {'priority: high ðŸ”¥': 'ðŸ”¥ High', 'priority: medium âš¡': 'âš¡ Medium', 'priority: low ðŸŒ±': 'ðŸŒ± Low'};
            const epicMap = {'epic: setup ðŸ“¦': 'ðŸ“¦ ì„¸íŒ…', 'epic: design-system ðŸŽ¨': 'ðŸŽ¨ ë””ìžì¸ì‹œìŠ¤í…œ', 'epic: auth ðŸ‘¤': 'ðŸ‘¤ ë¡œê·¸ì¸/íšŒì›ê°€ìž…', 'epic: profile ðŸ™â€â™‚ï¸': 'ðŸ™â€â™‚ï¸ í”„ë¡œí•„', 'epic: community ðŸ’¬': 'ðŸ’¬ ì»¤ë®¤ë‹ˆí‹°', 'epic: settings âš™ï¸': 'âš™ï¸ ì„¤ì •', 'epic: future ðŸ”®': 'ðŸ”® í–¥í›„ ê³„íš'};

            const priorityLabel = labels.find(l => l.startsWith('priority:'));
            const epicLabel = labels.find(l => l.startsWith('epic:'));

            const statusValue = 'Backlog';
            const priorityValue = priorityLabel ? priorityMap[priorityLabel] : null;
            const epicValue = epicLabel ? epicMap[epicLabel] : null;

            async function updateSelectField(field, value) {
              if (field && value) {
                const option = field.options?.find(o => o.name === value);
                if (option) { await github.graphql(updateFieldMutation, { pId: project.id, iId: itemId, fId: field.id, val: { singleSelectOptionId: option.id } }); }
              }
            }
            await updateSelectField(statusField, statusValue);
            await updateSelectField(priorityField, priorityValue);
            await updateSelectField(epicField, epicValue);

            if (sprintField && sprintValue) {
              const sprintMap = {"ðŸ Sprint 1 (Current: ~9/14)": "Sprint 1", "ðŸ—“ï¸ Sprint 2 (Planned)": "Sprint 2", "ðŸ—“ï¸ Sprint 3 (Planned)": "Sprint 3"};
              const targetTitle = sprintMap[sprintValue];
              if (targetTitle) {
                const iterations = sprintField.configuration.iterations;
                const targetIteration = iterations.find(it => it.title === targetTitle);
                if (targetIteration) { await github.graphql(updateFieldMutation, { pId: project.id, iId: itemId, fId: sprintField.id, val: { iterationId: targetIteration.id } }); }
              }
            }

            if (startDateField && startDateValue && startDateValue !== '_No response_') { 
              await github.graphql(updateFieldMutation, { pId: project.id, iId: itemId, fId: startDateField.id, val: { date: startDateValue } }); 
            }
            if (dueDateField && dueDateValue && dueDateValue !== '_No response_') { 
              await github.graphql(updateFieldMutation, { pId: project.id, iId: itemId, fId: dueDateField.id, val: { date: dueDateValue } }); 
            }

  # Job 3: [ìˆ˜ì •] ë¼ë²¨ ìˆ˜ë™ ì¶”ê°€ ì‹œ ì¤‘ë³µ ì œê±° ë° í”„ë¡œì íŠ¸ ìƒíƒœ ë™ê¸°í™”
  handle_label_changes:
    name: Handle Manual Label Changes
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'labeled'
    steps:
      - name: Cleanup duplicate prefix labels and sync project status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADD_TO_PROJECT_PAT }}
          script: |
            const payload_issue = context.payload.issue;
            const addedLabel = context.payload.label?.name;

            if (!addedLabel) { return; }

            const prefixes = ['status:', 'epic:', 'platform:', 'priority:', 'type:'];
            const addedLabelPrefix = prefixes.find(p => addedLabel.startsWith(p));

            if (!addedLabelPrefix) {
              console.log(`Label "${addedLabel}" does not have a managed prefix. Skipping.`);
              return;
            }

            // [ì˜¤ë¥˜ ìˆ˜ì •] ì´ë²¤íŠ¸ íŽ˜ì´ë¡œë“œì˜ ë¼ë²¨ ëª©ë¡ì€ ìµœì‹  ìƒíƒœê°€ ì•„ë‹ ìˆ˜ ìžˆìœ¼ë¯€ë¡œ,
            // REST APIë¥¼ í†µí•´ ìµœì‹  ì´ìŠˆ ì •ë³´ë¥¼ ê°€ì ¸ì™€ì„œ ì •í™•í•œ ë¼ë²¨ ëª©ë¡ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: payload_issue.number,
            });

            const currentLabels = issue.labels.map(l => l.name);
            const otherLabels = currentLabels.filter(l => !l.startsWith(addedLabelPrefix));
            const finalLabels = [...new Set([...otherLabels, addedLabel])];

            // setLabelsëŠ” labeled ì´ë²¤íŠ¸ë¥¼ ë‹¤ì‹œ íŠ¸ë¦¬ê±°í•  ìˆ˜ ìžˆìœ¼ë¯€ë¡œ, ì‹¤ì œ ë³€ê²½ì´ ìžˆì„ ë•Œë§Œ í˜¸ì¶œí•©ë‹ˆë‹¤.
            if (JSON.stringify(currentLabels.sort()) !== JSON.stringify(finalLabels.sort())) {
              await github.rest.issues.setLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: finalLabels
              });
              console.log(`Cleaned up labels for prefix "${addedLabelPrefix}". New labels: ${finalLabels.join(', ')}`);
            }
            
            const findItemQuery = `query($org: String!, $number: Int!) { organization(login: $org) { projectV2(number: $number) { id, items(first: 100) { nodes { id, content { ... on Issue { id, number, repository { name } } } } }, fields(first: 30) { nodes { ... on ProjectV2Field { id, name } ... on ProjectV2SingleSelectField { id, name, options { id, name } } } } } } }`;
            const projectData = await github.graphql(findItemQuery, { org: context.repo.owner, number: 1 });
            const project = projectData.organization.projectV2;
            const fields = project.fields.nodes;

            if (!project) {
              console.log("Project not found.");
              return;
            }

            const projectItem = project.items.nodes.find(item => item.content?.repository.name === context.repo.repo && item.content?.number === issue.number);

            if (!projectItem) {
              console.log(`Issue #${issue.number} not found in the project.`);
              return;
            }

            async function updateProjectField(fieldName, fieldValue) {
              const field = fields.find(f => f.name === fieldName);
              if (field && fieldValue) {
                const option = field.options?.find(o => o.name === fieldValue);
                if (option) {
                  const updateMutation = `mutation($pId: ID!, $iId: ID!, $fId: ID!, $val: String!) { updateProjectV2ItemFieldValue(input: { projectId: $pId, itemId: $iId, fieldId: $fId, value: { singleSelectOptionId: $val } }) { projectV2Item { id } } }`;
                  await github.graphql(updateMutation, { pId: project.id, iId: projectItem.id, fId: field.id, val: option.id });
                  console.log(`Project field "${fieldName}" for issue #${issue.number} updated to "${fieldValue}".`);
                } else {
                  console.log(`Option "${fieldValue}" not found for field "${fieldName}".`);
                }
              }
            }

            if (addedLabelPrefix === 'status:') {
              const statusMap = {'status: backlog ðŸ“‹': 'Backlog', 'status: ready âš¡': 'Ready', 'status: in-progress ðŸ”„': 'In Progress', 'status: review ðŸ‘€': 'In Review', 'status: done âœ…': 'Done', 'status: on-hold â¸': 'On Hold'};
              const newStatus = statusMap[addedLabel];
              if (newStatus) await updateProjectField('Status', newStatus);

            } else if (addedLabelPrefix === 'priority:') {
              const priorityMap = {'priority: high ðŸ”¥': 'ðŸ”¥ High', 'priority: medium âš¡': 'âš¡ Medium', 'priority: low ðŸŒ±': 'ðŸŒ± Low'};
              const newPriority = priorityMap[addedLabel];
              if (newPriority) await updateProjectField('Priority', newPriority);

            } else if (addedLabelPrefix === 'epic:') {
              const epicMap = {'epic: setup ðŸ“¦': 'ðŸ“¦ ì„¸íŒ…', 'epic: design-system ðŸŽ¨': 'ðŸŽ¨ ë””ìžì¸ì‹œìŠ¤í…œ', 'epic: auth ðŸ‘¤': 'ðŸ‘¤ ë¡œê·¸ì¸/íšŒì›ê°€ìž…', 'epic: profile ðŸ™â€â™‚ï¸': 'ðŸ™â€â™‚ï¸ í”„ë¡œí•„', 'epic: community ðŸ’¬': 'ðŸ’¬ ì»¤ë®¤ë‹ˆí‹°', 'epic: settings âš™ï¸': 'âš™ï¸ ì„¤ì •', 'epic: future ðŸ”®': 'ðŸ”® í–¥í›„ ê³„íš'};
              const newEpic = epicMap[addedLabel];
              if (newEpic) await updateProjectField('Epic', newEpic);
            }

  # Job 4: ë‹´ë‹¹ìž í• ë‹¹ì‹œ 'Ready' ìƒíƒœë¡œ ë³€ê²½
  move_assigned_to_ready:
    name: Handle Assignment (Move to Ready)
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'assigned'
    steps:
      - name: Set label and update project status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADD_TO_PROJECT_PAT }}
          script: |
            const issue = context.payload.issue;
            const existingLabels = issue.labels.map(l => l.name);
            let newLabels = existingLabels.filter(l => !l.startsWith('status:'));
            newLabels.push('status: ready âš¡');
            
            await github.rest.issues.setLabels({
              owner: context.repo.owner, repo: context.repo.repo,
              issue_number: issue.number, labels: newLabels
            });

            const findItemQuery = `query($org: String!, $number: Int!) { organization(login: $org) { projectV2(number: $number) { id, items(first: 100) { nodes { id, content { ... on Issue { id, number, repository { name } } } } }, fields(first: 20) { nodes { ... on ProjectV2SingleSelectField { id, name, options { id, name } } } } } } }`;
            const projectData = await github.graphql(findItemQuery, { org: context.repo.owner, number: 1 });
            const project = projectData.organization.projectV2;
            const projectItem = project.items.nodes.find(item => item.content?.repository.name === context.repo.repo && item.content?.number === issue.number);
            if (!projectItem) { return; }

            const statusField = project.fields.nodes.find(f => f.name === 'Status');
            const statusOption = statusField?.options.find(o => o.name === 'Ready');
            if (statusField && statusOption) {
              const updateFieldMutation = `mutation($pId: ID!, $iId: ID!, $fId: ID!, $val: String!) { updateProjectV2ItemFieldValue(input: { projectId: $pId, itemId: $iId, fieldId: $fId, value: { singleSelectOptionId: $val } }) { projectV2Item { id } } }`;
              await github.graphql(updateFieldMutation, { pId: project.id, iId: projectItem.id, fId: statusField.id, val: statusOption.id });
            }

  # Job 5: ì»¤ë°‹ ì—°ê²° ì‹œ 'In Progress' ìƒíƒœë¡œ ë³€ê²½
  move_linked_commit_to_progress:
    name: Handle Linked Commit (Move to In Progress)
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    steps:
      - name: Update status for linked issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADD_TO_PROJECT_PAT }}
          script: |
            const issueNumbers = new Set();
            const issueRegex = /#(\d+)/g;
            for (const commit of context.payload.commits) {
              let match;
              while ((match = issueRegex.exec(commit.message)) !== null) { issueNumbers.add(parseInt(match[1])); }
            }
            if (issueNumbers.size === 0) { 
              console.log('No linked issues found in commits.');
              return;
            }

            const findItemQuery = `query($org: String!, $number: Int!) { organization(login: $org) { projectV2(number: $number) { id, items(first: 100) { nodes { id, content { ... on Issue { id, number, repository { name } } } } }, fields(first: 20) { nodes { ... on ProjectV2SingleSelectField { id, name, options { id, name } } } } } } }`;
            const projectData = await github.graphql(findItemQuery, { org: context.repo.owner, number: 1 });
            const project = projectData.organization.projectV2;
            const statusField = project.fields.nodes.find(f => f.name === 'Status');
            const statusOption = statusField?.options.find(o => o.name === 'In Progress');

            if (!project || !statusField || !statusOption) {
              console.log('Project, Status field, or "In Progress" option not found. Aborting project updates.');
              return;
            }

            for (const issueNumber of issueNumbers) {
              try {
                const { data: issue } = await github.rest.issues.get({ owner: context.repo.owner, repo: context.repo.repo, issue_number: issueNumber });
                const existingLabels = issue.labels.map(l => l.name);
                if (!existingLabels.includes('status: in-progress ðŸ”„')) {
                  let newLabels = existingLabels.filter(l => !l.startsWith('status:'));
                  newLabels.push('status: in-progress ðŸ”„');
                  await github.rest.issues.setLabels({ owner: context.repo.owner, repo: context.repo.repo, issue_number: issueNumber, labels: newLabels });
                }
                
                const projectItem = project.items.nodes.find(item => item.content?.repository.name === context.repo.repo && item.content?.number === issueNumber);
                if (projectItem) {
                  const updateFieldMutation = `mutation($pId: ID!, $iId: ID!, $fId: ID!, $val: String!) { updateProjectV2ItemFieldValue(input: { projectId: $pId, itemId: $iId, fieldId: $fId, value: { singleSelectOptionId: $val } }) { projectV2Item { id } } }`;
                  await github.graphql(updateFieldMutation, { pId: project.id, iId: projectItem.id, fId: statusField.id, val: statusOption.id });
                  console.log(`Project status for issue #${issueNumber} updated to 'In Progress'.`);
                } else {
                  console.log(`Issue #${issueNumber} not found in the project.`);
                }
              } catch (error) { 
                console.log(`Failed to update issue #${issueNumber}:`, error.message); 
              }
            }

  # Job 6: ì´ìŠˆ Close ì‹œ 'Done' ìƒíƒœë¡œ ë³€ê²½
  handle_closed_issue:
    name: Handle Closed Issue (Move to Done)
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'closed'
    steps:
      - name: Set label and update project status to Done
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADD_TO_PROJECT_PAT }}
          script: |
            const issue = context.payload.issue;
            
            const existingLabels = issue.labels.map(l => l.name);
            let newLabels = existingLabels.filter(l => !l.startsWith('status:'));
            newLabels.push('status: done âœ…');
            
            await github.rest.issues.setLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: newLabels
            });
            console.log(`Label for issue #${issue.number} set to 'status: done âœ…'.`);

            const findItemQuery = `query($org: String!, $number: Int!) { organization(login: $org) { projectV2(number: $number) { id, items(first: 100) { nodes { id, content { ... on Issue { id, number, repository { name } } } } }, fields(first: 20) { nodes { ... on ProjectV2SingleSelectField { id, name, options { id, name } } } } } } }`;
            const projectData = await github.graphql(findItemQuery, { org: context.repo.owner, number: 1 });
            const project = projectData.organization.projectV2;
            const projectItem = project.items.nodes.find(item => item.content?.repository.name === context.repo.repo && item.content?.number === issue.number);

            if (!projectItem) {
              console.log(`Issue #${issue.number} not found in the project.`);
              return;
            }

            const statusField = project.fields.nodes.find(f => f.name === 'Status');
            const statusOption = statusField?.options.find(o => o.name === 'Done');
            
            if (statusField && statusOption) {
              const updateFieldMutation = `mutation($pId: ID!, $iId: ID!, $fId: ID!, $val: String!) { updateProjectV2ItemFieldValue(input: { projectId: $pId, itemId: $iId, fieldId: $fId, value: { singleSelectOptionId: $val } }) { projectV2Item { id } } }`;
              await github.graphql(updateFieldMutation, { pId: project.id, iId: projectItem.id, fId: statusField.id, val: statusOption.id });
              console.log(`Project status for issue #${issue.number} updated to 'Done'.`);
            } else {
              console.log('Could not find "Status" field or "Done" option in the project.');
            }

  # Job 7: ì´ìŠˆ Re-open ì‹œ 'In Progress' ìƒíƒœë¡œ ë³€ê²½
  handle_reopened_issue:
    name: Handle Reopened Issue (Move to In Progress)
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'reopened'
    steps:
      - name: Set label and update project status to In Progress
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADD_TO_PROJECT_PAT }}
          script: |
            const issue = context.payload.issue;
            
            const existingLabels = issue.labels.map(l => l.name);
            let newLabels = existingLabels.filter(l => !l.startsWith('status:'));
            newLabels.push('status: in-progress ðŸ”„');
            
            await github.rest.issues.setLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: newLabels
            });
            console.log(`Label for issue #${issue.number} set to 'status: in-progress ðŸ”„'.`);

            const findItemQuery = `query($org: String!, $number: Int!) { organization(login: $org) { projectV2(number: $number) { id, items(first: 100) { nodes { id, content { ... on Issue { id, number, repository { name } } } } }, fields(first: 20) { nodes { ... on ProjectV2SingleSelectField { id, name, options { id, name } } } } } } }`;
            const projectData = await github.graphql(findItemQuery, { org: context.repo.owner, number: 1 });
            const project = projectData.organization.projectV2;
            const projectItem = project.items.nodes.find(item => item.content?.repository.name === context.repo.repo && item.content?.number === issue.number);

            if (!projectItem) {
              console.log(`Issue #${issue.number} not found in the project.`);
              return;
            }

            const statusField = project.fields.nodes.find(f => f.name === 'Status');
            const statusOption = statusField?.options.find(o => o.name === 'In Progress');
            
            if (statusField && statusOption) {
              const updateFieldMutation = `mutation($pId: ID!, $iId: ID!, $fId: ID!, $val: String!) { updateProjectV2ItemFieldValue(input: { projectId: $pId, itemId: $iId, fieldId: $fId, value: { singleSelectOptionId: $val } }) { projectV2Item { id } } }`;
              await github.graphql(updateFieldMutation, { pId: project.id, iId: projectItem.id, fId: statusField.id, val: statusOption.id });
              console.log(`Project status for issue #${issue.number} updated to 'In Progress'.`);
            } else {
              console.log('Could not find "Status" field or "In Progress" option in the project.');
            }

  # PR ê´€ë ¨ ìžë™í™” Job
  pr_automation:
    name: Handle PR Status Change
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Update labels based on PR action
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const action = context.payload.action;
            const existingLabels = pr.labels.map(l => l.name);
            let labelsToSet = existingLabels.filter(label => !label.startsWith('status:'));
            
            if (action === 'ready_for_review') labelsToSet.push('status: review ðŸ‘€');
            else if (action === 'converted_to_draft') labelsToSet.push('status: in-progress ðŸ”„');
            else if (action === 'closed' && pr.merged) labelsToSet.push('status: done âœ…');
            else if (action === 'reopened') labelsToSet.push('status: in-progress ðŸ”„');
            
            if (JSON.stringify(existingLabels.sort()) !== JSON.stringify(labelsToSet.sort())) {
              await github.rest.issues.setLabels({ owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number, labels: [...new Set(labelsToSet)] });
            }

